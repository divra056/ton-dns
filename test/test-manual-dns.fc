;; // Manual DNS smart contract
;; // 
;; // 1) Processes external messages signage by the owner (public key storage)
;; // 2) Register new entries by signage external messages
;; // 3) Option to change owner
;; // 4) Responds to dnsresolve
;; // 
;; // - no seqno for now
;; // 

() main(slice signed_message) impure { 
  throw(2);
  var storage = get_data().begin_parse();
  var public_key = storage~load_uint(256);
  
  var (signature, message) = (signed_message~load_bits(512), signed_message);
  throw_unless(32, check_signature(slice_hash(message), signature, public_key));
  
  var opcode = signed_message~load_uint(8);
  throw_unless(33, opcode <= 1);
  
  accept_message();

  if opcode == 0 { ;; // register
    var request = message~load_ref().begin_parse();
    var key = request~load_ref().begin_parse();
    var entry = request~load_ref().begin_parse();
    request.end_parse();
    var category = entry~load_int(32);
    var value = entry;
    
    ;; // var dict = storage~load_dict();

    var d1 = new_dict()
      .idict_set_ref(32, category, begin_cell().store_slice(value).end_cell());
    var dict = new_dict()
      .idict_set_ref(256, slice_hash(key), d1);
    
    set_data(begin_cell()
      .store_uint(public_key, 256)
      .store_ref(dict)
      .end_cell());
  } 
  
  if opcode == 1 { ;; // change owner
    var new_public_key = signed_message~load_uint(256);
    var dict = storage~load_ref();
    set_data(begin_cell()
      .store_uint(new_public_key, 256)
      .store_ref(dict)
      .end_cell());
  }
}
