;; // recv_external -> main 

;; // Asm extensions

;; // PFXDICTGETQ (s D n – s' x s'' −1 or s')
;; // returns (found_prefix_key, found_value, remainder_of_key, found?=-1) or (null, null, key, 0)
(slice, slice, slice, int) pfxdict_get?(cell dict, int max_key_len, slice key) asm(key dict max_key_len) "PFXDICTGETQ" "NULLROTRIFNOT" "NULLROTRIFNOT";

;; // PFXDICTGET  (s D n – s' x s'' )
;; // returns (found_prefix_key, found_value, remainder_of_key) or throws deserialization failure exception
(slice, slice, slice) pfxdict_get!(cell dict, int max_key_len, slice key) asm(key dict max_key_len) "PFXDICTGET";

;; // PFXDICTSET (x k D n – D' −1 or D 0)
;; // returns (modified_dict, ok?=-1) or (dict, 0)
(cell, int) pfxdict_set(cell dict, int max_key_len, slice key, slice value) asm(value key dict max_key_len) "PFXDICTSET";

;; // todo remaining methods:
;; // PFXDICTREPLACE (x k D n – D' −1 or D 0).
;; // PFXDICTADD (x k D n – D' −1 or D 0).
;; // PFXDICTDEL (k D n – D' −1 or D 0).


;; // Implementation

(int, int, cell) load_storage() impure {
  var storage = get_data().begin_parse();
  var seqno = storage~load_uint(32);
  var public_key = storage~load_uint(256);
  var root_dict = storage~load_ref();
  storage.end_parse();
  return (seqno, public_key, root_dict);
}

() set_storage(int seqno, int public_key, cell root_dict) impure {
    set_data(begin_cell()
      .store_uint(seqno, 32)
      .store_uint(public_key, 256)
      .store_ref(root_dict)
      .end_cell());
}

(int, slice) verify_message(slice in_msg, int public_key, int stored_seqno) impure {
  var signature = in_msg~load_bits(512);
  throw_unless(32, check_signature(slice_hash(in_msg), signature, public_key));
  var (seqno, op) = (in_msg~load_uint(32), in_msg~load_int(32));
  throw_unless(33, seqno == stored_seqno);
  throw_unless(34, 0 <= op);
  throw_unless(34, op <= 1); ;; // no && 
  return (op, in_msg);
}

cell handle_register(slice message, cell stored_dict) impure {

  var name = message~load_ref().begin_parse();
  var dns_dict = message~load_ref();
  message.end_parse();
  
  var dict = new_dict(); ;; // fixme! this is wrong

  var ok? = dict~pfxdict_set(1023, name, dns_dict.begin_parse());
  throw_unless(35, ok?);
  return dict;
}

int handle_change_owner(slice message) impure {
  var new_public_key = message~load_uint(256);
  message.end_parse();
  return new_public_key;
}

(int, cell) handle_dnsresolve(cell root_dict, slice query_string, int category) {
  var (key, value, rem_query, found?) = pfxdict_get?(root_dict, 1023, query_string);
    if found? {
      return (0, begin_cell().store_slice(value).end_cell());
    } else {
      return (-1, new_dict()) ;
    }
}

;; // Public API

() main(slice in_msg) impure { 
  
  var (seqno, public_key, root_dict) = load_storage();
  var (op, message) = verify_message(in_msg, public_key, seqno);
  accept_message();

  if op == 0 { ;; // register
    var new_root_dict = handle_register(message, root_dict);
    set_storage(seqno + 1, public_key, new_root_dict);
  } 
  if op == 1 { ;; // change owner
    var new_public_key = handle_change_owner(message);
    set_storage(seqno + 1, new_public_key, root_dict);
  }
}

int seqno() method_id {
  return get_data().begin_parse().preload_uint(32);
}

(int, cell) dnsresolve(slice query_string, int category) method_id {
  var root_dict = get_data().begin_parse().skip_bits(32 + 256).preload_ref();
  return handle_dnsresolve(root_dict, query_string, category);
}
